

学习C++语法的重点：==运行时bug变成编译时的bug==

# 2.访问权限

| 访问权限  | 作用                                           |
| --------- | ---------------------------------------------- |
| public    | 公共访问权限(类外可以访问)                     |
| private   | 私有访问权限(只有类内可以访问)                 |
| protected | 受保护的访问权限(类外如果认他作干爹就可以访问) |
| friend    | 友元函数访问权限，可以访问私有成员(隔壁老王)   |
|           |                                                |

如果不进行访问权限设置，默认是私有权限







# 3.构造函数与析构函数

| 构造/析构函数            | 使用方式            |
| ------------------------ | ------------------- |
| 默认构造函数             | People a;           |
| People(string name);     | People a("hug");    |
| People(const People &a); | 拷贝构造，与=不等价 |
| ~People();               | 无                  |
|                          |                     |

1. 在构造函数中申请资源，在析构函数中释放资源！

2. 为什么在先构造的后析构？

   ==因为后构造的可能要用到先构造的对象的信息。==

# 4.成员/对象方法与成员/对象属性

1. 成员方法可以访问this指针
2. 跟着对象走，存储在不同变量之内





# 5.类属性与类方法

1. 跟着类走，所有对象共享一个类属性

   即全局唯一，大家共享

2. 加上`static`关键字就能声明类属性了。

3. 类方法中访问不到this指针





# 6.CONST方法

1. 目标--把运行时的bug变成编译时的bug

2. 语义信息：不改变对象中任意一个属性

3. 作用：

   被const类型的对象调用(const类型对象只能调用const类型的方法，反之不成立)

   







# 7.返回值优化

关闭返回值优化的编译条件

```c++
g++ -fno-elide-constructors xxx.cpp
```





# 8.运算符重载

1. cin和cout是两个对象

2. 重载运算符只能重载逻辑功能， 不能改变优先级和传入参数个数

3. 优先匹配类内重载

4. 函数对象--》长得像函数的对象---通过重载()来实现

5. 数组对象--》长得像数组的对象--通过重载[]来实现

6. 指针对象--》长得像指针的对象--通过重载->来实现

7. 类外重载，==就只看成一个运算符了 而不是成员方法！！==

8. 有4类运算符只能在类内重载，==必须和某个类绑定！！==

   `() [] ->  = `

9. 有5个不能重载的运算符！

   `.   .*   sizeof()   ?:     ::`

