

学习C++语法的重点：==运行时bug变成编译时的bug==，即**C++会让你把错误尽量暴露在编译阶段**



# 0.存储空间

类的存储空间

跟struct是一样的。



# 1.类型与变量--类与对象

1. 这俩其实是一回事。
2. 复杂的类型--类(class)

# 2.访问权限

| 访问权限  | 作用                                           |
| --------- | ---------------------------------------------- |
| public    | 公共访问权限(类外可以访问)                     |
| private   | 私有访问权限(只有类内方法可以访问)             |
| protected | 受保护的访问权限(类外如果认他作干爹就可以访问) |
| friend    | 友元函数访问权限，可以访问私有成员(隔壁老王)   |

1. 如果不进行访问权限设置，默认是私有权限(而struct默认是公有，这是struct和class唯一的区别)
2. 例子:==29/2.class/1.cpp==
3. 友元和前置声明一样，都是属于能尽量不用就不要用的功能！
   + 友元的功能很简单，就是==赋予别人访问自己的`protected private`成员的能力==
   + 友元不能被继承！





# 3.构造函数与析构函数

| 构造/析构函数(==一般都是public==)                          | 使用方式                                                     |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 默认构造函数People() {}                                    | People a;                                                    |
| 有参构造函数People(string name);                           | People a("hug"); / People a = string("hug");                 |
| 拷贝构造函数People(const People &a); ==其实可以不加const== | People a(b); / People a = b; ==而若不是定义，只是简单赋值比如 a = b;则是调用operater"="== |
| ~People();                                                 | 无                                                           |

## 3.0构造函数的结构

1. 函数名和形参
2. 初始化列表(***<u>即使没有初始化列表，编译器也会初始化成员属性</u>***)
   + 如果没有初始化列表，就称作隐性
   + 有，就是显性
   + ==在进入构造函数的{}之前，所有属性都被初始化完毕了！==
3. 函数逻辑
   + 即`{}`



## 3.1默认构造函数

1. 如果自己不重载默认构造函数`People() {}`,那么系统会自动分配这个默认构造函数，其功能是--什么也不做。

2. 自己可以重载默认构造函数，重载了之后系统的默认构造函数就会***<u>销毁</u>***。

3. 如果你重载了类内***<u>任意一个构造函数</u>***(不管是有参还是拷贝)，系统默认的构造函数就会销毁！

   如果还想其存在，就可以加上一行

   ```c++
   People() = {}
   //或者是
   People() = default;
   
   //如果想销毁
   People() = delete;
   ```

   

   





## 3.2有参构造函数

1. 即构造函数中的参数列表==有形参==的构造函数！

2. 使用方式如上表所示！

3. 如果形参只有一个，就叫做**转换构造函数**！

   ```c++
   People(string name) {
       this->name = name;
   }
   
   People a = string("hug");//可以理解为将一个string转换成一个类！！！
   ```

4. ==只有==转换构造函数，可以不在定义的时候调用！！！

   ==上句话存疑，因为实践证明，现在的C++机制中好像是只有定义的时候调用构造函数，其他情况都不调用！！！！==

   ```c++
   People b;//在这里定义
   
   b = string("wangjialong") //这里的过程很有意思！！！
   //先是创建一个匿名对象，并调用其转换构造函数将string类转换为People对象
   //接着调用operator=,即赋值运算符
   //最后销毁匿名对象
   ```





## 3.3拷贝构造函数

1. 为什么copy constructror要传引用？

   ***<u>否则会无限递归！！</u>***

2. 形参可以不用加==const==

3. 拷贝构造的引用场景

   + `People a = b;  或者是People a(b);`  
   + `形参实参结合`
   + `函数返回值是对象，函数执行完成返回的时候`



## 3.4析构函数

1. 一般都是在构造函数中申请资源，在析构函数中释放资源！

2. 为什么在先构造的后析构？

   ==因为后构造的可能要用到先构造的对象的信息。==





# 4.成员/对象方法与成员/对象属性

1. 成员方法可以访问this指针
2. 跟着***<u>对象走</u>***，存储在不同对象之内





# 5.类属性与类方法

1. 跟着***<u>类</u>***走，所有对象共享一个类属性

   即全局唯一，大家共享

2. 加上==`static`==关键字就能声明类属性了。

3. ***<u>类属性必须在类外初始化！！！</u>***

4. 类属性既可以用类调用，也可以用对象调用。

5. 类方法中访问不到this指针





# 6.CONST方法

1. 使用：在形参列表之后，加一个`const`关键字。

2. 语义信息：==不改变对象中任意一个属性==

   + 如果想在const方法中修改某个变量，必须将此变量的声明前加上`mutable`关键字

3. 目标-->==把运行时的bug变成编译时的bug==

4. 作用：

   被const类型的对象调用(***<u>const类型对象只能调用const类型的方法</u>***，反之不成立)

   







# 7.返回值优化

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghg8tmeqznj311k0hkn8l.jpg)

1. 没有优化： 2次拷贝
2. GNU系编译器的优化后：==0拷贝行为==。
3. 关闭返回值优化的编译条件

```c++
g++ -fno-elide-constructors xxx.cpp
```





# 8.运算符重载

代码演示：==~/29/2.class/6 7 8.cpp==

1. 重载运算符只能重载逻辑功能， 不能改变优先级和传入参数个数

2. 优先匹配类内重载

3. 设计要点：

   + ***<u>返回值类型</u>***！
   + ***<u>传入参数类型</u>***！

   

## 8.1类内重载

1. cin和cout是两个对象，cin重载了`>>`运算符，cout重载了`<<`运算符

2. 类内重载就是绑定了一个类！==`cin >> x` 相当于 `cin.operator>>(x)`==

   ```c++
   //在haizei命名空间中的class istream中
   
   istream &operator>>(int &x) {
       std::cin >>x;
       return *this;
   }
   ```

   



## 8.2类外重载

1. 类外重载，就不绑定类了！==就只看成一个运算符了 而不是成员方法！！==

   so, ==`cin >> x`==就应该设计为==`istream &operator>>(istream &in, int x)`==，==几元运算符就有几个形参！==

   ```c++
   haizei::istream &operator>>(haizei::istream &in, int &x) {
       in >> x;
       return in;
   }
   ```

2. 小任务：

   ```c++
   cout + 8 + 9 + 10;//使这行合法，效果：输出8 9 10
   
   //因为std::cout不是我们实现的，所以只能在类外重载
   
   ostream &operator+(ostream &out, const int &x) {
       out << z;
       return out;
   }
   ```





## 8.3几个常规运算符的重载

1. +=
2. 前++
3. 后++(==与前者的区分在于后++形参有一个int(虽然没什么用)==)





## 8.4几个特殊运算符的重载

1. 函数对象--》长得像函数的对象---通过重载()来实现
2. 数组对象--》长得像数组的对象--通过重载[]来实现
3. 指针对象--》长得像指针的对象--通过重载->来实现

4. 有4类运算符只能在类内重载，==必须和某个类绑定！！==

   `() [] ->  = `

5. 有5个不能重载的运算符！

   `.   .*   sizeof()   ?:     ::`







# 9.深拷贝与浅拷贝

1. C++默认的`copy constructor`没那么智能！是浅拷贝！

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghg920cxalj30s60p5wlw.jpg)

   ==a是一个对象，b是拷贝a的对象，他俩的arr数组指向的是同一块区域！==

2. 深拷贝需要自己实现拷贝构造函数！

   ```c++
   class A {
   public:
       A() {
           arr = new int[10];
       }
       A(const A &a) : A() {//显示调用默认构造函数创建存储区来实现深拷贝
           for (int i = 0; i < 10; i++) {
               this->arr[i] = a.arr[i];//手动赋值
           }
           this->x = x;
           this->y = y;
       }
   private:
       int x, y;
       int *arr;
   };
   ```

   