# 1.auto关键字

## 1.1C语言中的auto关键字

1. auto代表自动变量
2. 作用和局部变量是一样的
3. 非常==鸡肋==，没有什么实际作用



## 1.2C++中的auto关键字

1. 作用：

   进行==自动类型推导==

   ```c++
   auto a = 123;//可以推导出是int
   
   
   map<int, int> arr;
   arr[213] = 234;
   arr[34] = 5324;
   arr[546] = 4325;
   for (auto iter = arr.begin(); iter != arr.end(); iter++) {
       cout << iter->first << " " << iter->second << endl;
   }
   //c++中新的遍历方法
   for (auto x : arr) {
       cout << x.first << " " << x.second << endl;
   }
   ```

2. 不能作用的场景：

   + 函数形参

     ```c++
     int f(auto x, auto y) {
         return x + y;
     }
     ```

   + 模板参数

   + 定义数组

     ```c++
     auto arr[3] = {1, 2, 3}
     ```

   + 非静态成员变量

     ```c++
     //因为非静态成员变量只是声明，在编译时不知道如何推导其类型
     
     static const auto x = 123; //这是静态成员变量， 必须加const，必须在类内初始化
     ```

     



#  2.constexper关键字

1. 作用：

   ==保证当前定义的变量在编译期就能确定值==！

   需要每个过程都是确定的！

2. const关键字定义的量是***<u>运行期常量</u>***！

   ```c++
   int n;
   cin >> n;
   const int m = 2 * n;//不会报错，说明是运行期常量
   ```

3. constexpr关键字定义的量是***<u>严格的编译期常量</u>***！

   ```c++
   //如果把上面那个代码的第三行改成
   constexpr int m = 2 * n;//就会报错！
   ```

4. 可以修饰***<u>常量</u>***，***<u>函数(包括构造函数)</u>***，***<u>对象</u>***，但是在C++14之前不允许修饰***<u>递归函数</u>***！！





# 3.final关键字

1. 作用：

   + ==防止子类对父类中相关虚函数的重载==！

     ```c++
     void say() final {
         
     }
     ```

     

   + ==防止被继承==！--即用于单例模式

     ```c++
     class B final {};
     ```





# 4.nullptr关键字

1. 作用
   + 更==严格地==代表空地址--> 0
   + `NULL`其实本质是`(void *)0`







# 5.左右值引用

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghgbj5led4j319b0ptqa5.jpg)

1. 左值、右值、左值引用、右值引用是四个不同的概念！！

2. 即左值引用可以绑定在右值上！

   但是一个左值无法绑定到右值引用上！

3. 左右值的提出将C++拉回神坛！

4. 其最关键作用：

   ==区分流程==





## 5.1左右值

1. 区分方法1：(==这个比较深奥==，是光哥总结的)

   这个值到了下一行，==同样的变量、单一的方式能否访问到同样的结果==，如果能，就是左值，否则就是右值。

   ```c++
   int a;
   a = 123 + 456;
   //a是左值
   //123 456  123+456都是右值
   
   
   a++;//右值
   ++a;//左值
   ```

2. 区分方法2：(==这个比较好判断==)

   ==这个值能否放在等号左边==，如果能，就是左值，不能就是右值

   ```c++
   int a, b = 1, c = 3;
   a = (b + c);//(b + c)是个右值
   
   (++a) = (b + c);//++a是左值，所以能放到等号左边
   
   int arr[10];
   arr[3] = 12;//[]返回左值
   
   //作用于自身的双目运算符返回值通常都是左值！
   (a += 3) = 67;
   (a = b) = c;//赋值表达式是左值，返回的值是a的引用！！！！！
   ```

   

3. 左值代表==常驻==在程序中的值

4. 右值表==临时==，它是临时值





## 5.2左/右值引用

1. 左值引用即一个`&`，  右值引用即`&&`

2. 左值==优先==绑定到左值引用上，右值==优先绑==定到右值引用上。

3. 左右值引用转换

   + `forward`

     ```c++
     forward<int &&>(x)  //x优先匹配右值引用
     ```

   + `move`

     ***<u>强制性</u>***匹配右值引用

4. 左值引用可以绑定在右值上！

   ***<u>只有const类型的左值引用可以这么做！</u>*** 并且这个右值也得是const

   ==This is why 拷贝构造函数形参都是const &！！==

5. 但是一个左值无法绑定到右值引用上！



## 5.3move_constructor

==这是C++11引入右值之后最为强大的东西！！！==

参考资料：

+ https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-04-basic.html
+ http://c.biancheng.net/view/7847.html

1. 作用：

   ==将右值的存储空间直接赋值给所需要的，免去拷贝过程！==

   PS：GNU系列编译器会帮我们进行返回值优化，免去拷贝过程！

2. 例子：

   + 在实现这个例子时，必须关掉g++的返回值优化！

   ```c++
   g++ -fno-elide-constructors  xxx.cpp
   ```

   ```c++
   //在~/29.Cpp/5./7.move_constructor.cpp中
   //这个类中有一个自己实现的string类
   
   haizei::string s1 = "hello world!", s2 = ", haizei", s3 = ", harbin.";
   cout << "======s4 begin=======" << endl;
   haizei::string s4 = s1 + s2 + s3;
   cout << "======s4 end=========" << endl;
   
   //会输出什么？
   ```

   + 会输出这样

     ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghhf26791bj30eq08275j.jpg)

     + ***<u>前四行是第一个+的过程！</u>***

     + 也就是说，首先会调用s1的operator+，这个方法中会创建一个匿名对象(990)，方法调用结束前，会拷贝给另一个对象a70(这部分属于返回值优化的内容)，最后990会销毁。
     + 但是这个拷贝行为完全没有必要！
     + 因为string类中要开辟一段存储空间！不如最后方法调用结束前，让方法返回的对象中==直接指向匿名对象那段存储区==，这样就免得拷贝了！

     ```c++
     string(string &&s) : 初始化列表 {
         //为啥要写右值引用？？？因为匿名对象是个右值！！临时值！！
         cout << "move constructor : " << this << endl;
         this->buff = s.buff;//直接指向匿名对象的存储空间，免得拷贝行为
         s.buff = nullptr;
     }
     ```

   + 修改之后的输出结果

     ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ghhff63j6bj30f208amyc.jpg)

     