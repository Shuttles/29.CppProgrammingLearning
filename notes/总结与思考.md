# 1.auto关键字

## 1.1C语言中的auto关键字

1. auto代表自动变量
2. 作用和局部变量是一样的
3. 非常==鸡肋==，没有什么实际作用



## 1.2C++中的auto关键字

1. 作用：

   进行==自动类型推导==

   ```c++
   auto a = 123;//可以推导出是int
   
   
   map<int, int> arr;
   arr[213] = 234;
   arr[34] = 5324;
   arr[546] = 4325;
   for (auto iter = arr.begin(); iter != arr.end(); iter++) {
       cout << iter->first << " " << iter->second << endl;
   }
   //c++中新的遍历方法
   for (auto x : arr) {
       cout << x.first << " " << x.second << endl;
   }
   ```

2. 不能作用的场景：

   + 函数形参

     ```c++
     int f(auto x, auto y) {
         return x + y;
     }
     ```

   + 模板参数

   + 定义数组

     ```c++
     auto arr[3] = {1, 2, 3}
     ```

   + 非静态成员变量

     ```c++
     //因为非静态成员变量只是声明，在编译时不知道如何推导其类型
     
     static const auto x = 123; //这是静态成员变量， 必须加const，必须在类内初始化
     ```

     



#  2.constexper关键字

1. 作用：

   ==保证当前定义的变量在编译期就能确定值==！

   需要每个过程都是确定的！

2. const关键字定义的量是***<u>运行期常量</u>***！

   ```c++
   int n;
   cin >> n;
   const int m = 2 * n;//不会报错，说明是运行期常量
   ```

3. constexpr关键字定义的量是***<u>严格的编译期常量</u>***！

   ```c++
   //如果把上面那个代码的第三行改成
   constexpr int m = 2 * n;//就会报错！
   ```

4. 可以修饰***<u>常量</u>***，***<u>函数(包括构造函数)</u>***，***<u>对象</u>***，但是在C++14之前不允许修饰***<u>递归函数</u>***！！





# 3.final关键字

1. 作用：

   + ==防止子类对父类中相关虚函数的重载==！

     ```c++
     void say() final {
         
     }
     ```

     

   + ==防止被继承==！--即用于单例模式

     ```c++
     class B final {};
     ```





# 4.nullptr关键字

1. 作用
   + 更==严格地==代表空地址--> 0
   + `NULL`其实本质是`(void *)0`







# 5.左右值引用

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghgbj5led4j319b0ptqa5.jpg)

1. 左值、右值、左值引用、右值引用是四个不同的概念！！

2. 即左值引用可以绑定在右值上！

   但是一个左值无法绑定到右值引用上！

3. 左右值的提出将C++拉回神坛！

4. 其最关键作用：

   ==区分流程==





1. 区分方法1：(==这个比较深奥==，是光哥总结的)

   这个值到了下一行，==同样的变量、单一的方式能否访问到同样的结果==，如果能，就是左值，否则就是右值。

   ```c++
   int a;
   a = 123 + 456;
   //a是左值
   //123 456  123+456都是右值
   
   
   a++;//右值
   ++a;//左值
   ```

2. 区分方法2：(==这个比较好判断==)

   ==这个值能否放在等号左边==，如果能，就是左值，不能就是右值

   ```c++
   int a, b = 1, c = 3;
   a = (b + c);//(b + c)是个右值
   
   (++a) = (b + c);//++a是左值，所以能放到等号左边
   
   int arr[10];
   arr[3] = 12;//[]返回左值
   
   //作用于自身的双目运算符返回值通常都是左值！
   (a += 3) = 67;
   (a = b) = c;//赋值表达式是左值，返回的值是a的引用！！！！！
   ```

   

3. 左值代表==常驻==在程序中的值

4. 右值表==临时==，它是临时值





## 左/右值引用

1. 左值引用即一个`&`，  右值引用即`&&`

2. 左值==优先==绑定到左值引用上，右值==优先绑==定到右值引用上。

3. 左右值引用转换

   + `forward`

     ```c++
     forward<int &&>(x)  //x优先匹配右值引用
     ```

   + `move`

     ***<u>强制性</u>***匹配右值引用

4. 左值引用可以绑定在右值上！

   ***<u>只有const类型的左值引用可以这么做！</u>*** 并且这个右值也得是const

5. 但是一个左值无法绑定到右值引用上！



## move_constructor

1. 将右值的存储空间直接赋值