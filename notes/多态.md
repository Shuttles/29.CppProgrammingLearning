

# 太长不看版

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghfymqt6t6j31y00tsap7.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ghfq7iwbsgj31ev0u0e5r.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghfq7m34cvj31p20l0k6x.jpg)

PS：

和重载成员函数的区别：

1. 重载成员函数，形参个数和类型是==不同==的。
2. 而虚函数形参个数和类型都是==相同==的。



PS：

1. 在子类中调用父类**同名且同参数函数**的方法：

   域作用运算符

# 0.引入

1. 即非多态下的问题

   --==父类指针无法调用子类同名方法==(本质是因为，普通的成员方法跟着==类==走)

   ```c++
   class Animal {
   public :
       Animal(const string &name): __name(name) {}
       void run() {
           cout << "I don't know how to run" << endl;
       }
       ~Animal() {}
   protected:
       string __name;
   };
   
   
   class Cat : public Animal {
   public:
       Cat() : Animal("cat") {}
       void run() {
           cout << "I can run with four legs." << endl;
       }
   };
   
   
   int main() {
       Cat a;
       Animal &b = a;
       Animal *c = &a;
       
       //这三个的结果不一样，因为声明的类不一样
       a.run();//调用Cat
       b.run();//Animal
       c->run();//Animal
       
       return 0;
   }
   
   ```

2. 只要父类中的run变成==虚函数==，就可以解决这一问题，因为虚函数成员方法跟着==对象==走。

3. ==有虚函数的父类与其子类的继承关系称为多态==



# 1.虚函数

1. 普通的成员方法跟着==类==走。

2. 虚函数成员方法跟着==对象==走

   + 在成员方法前加上`virtual`关键字即可声明为虚函数

   + 最好在子类中的同名函数的声明后面加上`override`

   + `override`关键字是帮我们找bug的！

     ==明确==了我们要重写的这个函数是虚函数！

   + 应用场景：

     一组对象的***<u>表现方式不一样，调用方式一样</u>***！

3. 在拥有继承关系的类中，父类的==析构函数一定==得是虚函数！！！

   否则会发生内存泄漏--子类析构函数没有被调用！

   ```C++
   Base *a = new Base_A();//用父类标识符声明子类对象
   delete ba;//这样不会调用子类的析构函数，导致内存泄漏！！
   ```

   

4. 只要父类中的相应方法是虚函数，子类中的相应方法==一定==是虚函数！！！

   但是在工程中一般都要标记一下，给程序员看！！



# 2.编译期状态、运行时状态

1. 前者就是编译期就可以确定的状态，后者是必须运行时才可以知道的状态。
2. 运行时状态需要维护额外的信息。
3. 编译期常量
   + 需要整个初始化过程中的常量、函数都是编译期常量！！





# 3.虚函数的实现原理

1. 含有虚函数的对象(==多态的==)的存储空间

   + 首先是一个8字节的指针变量--》存的是虚函数表的地址(表中是许多函数地址)
   + 其次存的是数据

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghcml803syj315m0la10t.jpg)

2. 虚函数表

   + **一个类对应一张虚函数表**

   + **每个类的所有对象对应一张虚函数表。**

3. ==this指针是成员方法的第一个隐藏参数！！==

4. 如何利用==3的结论==来进行函数的返回值优化？

   在函数中你的每一次操作对象，***<u>把外部你想操作的对象的地址作为第一个参数</u>***！





# 3.纯虚函数

1. 父类中不需要实现

   ```c++
   virtual void func() = 0;
   ```

2. 拥有纯虚函数的类==不能==实例化出对象，==称为抽象类，也称接口类==

   + 可以类比USB接口，**只是规定了形式，没有规定功能**。

   + 继承了接口类的子类必须实现父类中的纯虚函数(***<u>其实也不是必须，只不过如果不实现就不能创建该类的对象了</u>***)。
   + 纯虚函数也称接口方法。

3. 应用小例子：

   实现一个可以自定义哈希函数的哈希表类，其中，传入的哈希函数既可以是函数，也可以是函数对象







# 4.光哥提问

## 4.1如何发现有一张虚函数表?

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghfp3cw3npj31660jwdsh.jpg)

1. 创建一个A类，里面不声明变量，但是定义一个普通成员方法。sizeof(A)-->1
2. 将那个普通成员方法改成虚函数，这样的话sizeof(A)-->8，这就说明其实有虚函数的对象多了一块存储空间，正好是8字节，合理推测是个指针变量，存储的是==虚函数表==的地址，而虚函数表里每个位置都存的是一个函数地址。
3. 通过函数指针方法调用虚函数表第一个函数(61行)，发现调用成功，这就验证了我们的猜想

## 4.2如何发现this指针是隐藏参数？

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghfpk4jfxoj31620oa7iv.jpg)

1. 将那个虚函数成员方法中加入一个形参，并在方法中输出这个形参的值。
2. 再次用函数指针形式调用这个虚函数，并传入一个参数，发现输出的并不是所传入的参数
3. 而若在那个虚函数中输出this，发现this是刚刚传入的参数，由此可见，我们传入的实参其实赋给了this，由此可以验证，***<u>this是成员方法的第一个隐藏参数！</u>***



![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ghfpk0lkqaj314k0icq9l.jpg)

1. 修改虚函数的实现，在其中增加输出本对象的一个成员属性值。
2. 再次以函数指针形式调用那个虚函数，但是第一个参数传入的是temp_b的地址。
3. 发现输出结果中，输出的是temp_b对象的成员属性值，更加验证了==this指针是成员方法的第一个隐藏参数！==









# 5.利用虚函数表进行类型转换--dynamic_cast

1. 作用

   ==从父类指针到子类地址的转换==

2. 使用

   ```c++
   if (dynamic_cast<子类类型 *>(父类指针)) {
       cout << "转换成功" << endl;
   } else {
       //返回空地址
       cout << "转换失败" << endl;
   }
   ```

3. 使用原理

   + 使用前提：

     父类一定是多态的！(==即有虚函数==)

   + 那么为什么要求父类是多态的呢？？

     ***<u>因为每个子类对应一个独特的虚函数表！</u>***

     ==利用虚函数表的异同来判断是否能转换成功！==

4. 利用其原理自己实现一个`dynamic_cast`

   ```c++
   int my_dynamic_cast(A *ta) {
       char **pa = (char **)(ta);
       char **pb = (char **)(new B());
       char **pc = (char **)(new C());
       char **pd = (char **)(new D());
       int ret = 1;
       if (pa[0] == pb[0]) ret = 0;       //利用虚函数表的地址来判断转换成哪个子类！！
       else if (pa[0] == pc[0]) ret = 1;
       else if (pa[0] == pd[0]) ret = 2;
       return ret;
   }
   ```







