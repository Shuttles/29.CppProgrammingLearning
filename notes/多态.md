

# 0.引入

1. 即非多态下的问题

   --==父类指针无法调用子类同名方法==(本质是因为，普通的成员方法跟着==类==走)

   ```c++
   class Animal {
   public :
       Animal(const string &name): __name(name) {}
       void run() {
           cout << "I don't know how to run" << endl;
       }
       ~Animal() {}
   protected:
       string __name;
   };
   
   
   class Cat : public Animal {
   public:
       Cat() : Animal("cat") {}
       void run() {
           cout << "I can run with four legs." << endl;
       }
   };
   
   
   int main() {
       Cat a;
       Animal &b = a;
       Animal *c = &a;
       
       //这三个的结果不一样，因为声明的类不一样
       a.run();//调用Cat
       b.run();//Animal
       c->run();//Animal
       
       return 0;
   }
   
   ```

2. 只要父类中的run变成==虚函数==，就可以解决这一问题，因为虚函数成员方法跟着==对象==走。

3. 有虚函数的父类与其子类的继承关系称为==多态==



# 1.虚函数

1. 普通的成员方法跟着==类==走。

2. 虚函数成员方法跟着==对象==走

   + 在成员方法前加上`virtual`关键字即可声明为虚函数

   + 最好在子类中的同名函数的声明后面加上`override`

   + `override`关键字是帮我们找bug的！

   + 应用场景：

     一组对象的***<u>表现方式不一样，调用方式一样</u>***！

3. 在拥有继承关系的类中，父类的==析构函数一定==得是虚函数！！！

   否则会发生内存泄漏--子类析构函数没有被调用！

   ```C++
   Base *a = new Base_A();//用父类标识符声明子类对象
   delete ba;//这样不会调用子类的析构函数，导致内存泄漏！！
   ```

   

4. 只要父类中的相应方法是虚函数，子类中的相应方法==一定==是虚函数！！！

   但是在工程中一般都要标记一下，给程序员看！！



# 2.编译期状态、运行时状态

1. 前者就是编译期就可以确定的状态，后者是必须运行时才可以知道的状态。
2. 运行时状态需要维护额外的信息。





# 3.虚函数的实现原理

1. 含有虚函数的对象(==多态的==)的存储空间
   + 首先是一个8字节的指针变量--》存的是虚函数表(表中是许多函数地址)
   + 其次存的是数据





==this是成员方法的第一个隐藏参数！==







# 3.纯虚函数

1. 父类中不需要实现

   ```c++
   virtual void func() = 0;
   ```

2. 拥有纯虚函数的类不能实例化出对象，==称为抽象类，也称接口类==

3. 继承了接口类的子类必须实现父类中的纯虚函数。





# 4.虚函数表

1. 一个类对应一张虚函数表
2. 每个类的所有对象对应一张虚函数表。