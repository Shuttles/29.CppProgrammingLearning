

# 0.综述

1. 算法：

   能够操作存储***<u>任意类型</u>***数据的数据结构

2. 函数的目的：

   将==具体类型==从程序设计中抽象出来。-->一步抽象

3. 模板的目的：

   将==任意类型==从程序设计中抽象出来。   -->两步抽象



例子：add模板 

> 从
>
> `3 + 4`
>
> 到
>
> `int add(int a, int b)`
>
> 到
>
> ```c++
> template<typename T>
> T add(T a, T b) {
>     return a + b;
> }
> ```
>
> 再到最终的没有bug的add模板





泛型编程：

1. 面向过程编程：

   用模板实现***<u>函数过程</u>***

2. 面向对象编程：

   用模板实现***<u>类</u>***



# 1.基础语法

1. 在编写函数或类前加上template关键字及其参数即可

   ==模板参数就是我们抽象出来的类型！！==

   ```c++
   template<typename T> //typename和class没有任何区别！！
   ```

2. 模板函数

   ```c++
   template<typename T>
   T add(T a, T b) {
       return a + b;          //这个其实有bug，因为只能实现同类型的加法
   }
   ```

3. 模板类

   ```c++
   template<typename T>
   class PrintAny {
       void operator()(const T &a) {   //输出任意类型！！
           cout << a << endl;  
       }
   };
   ```





# 2.作用阶段

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghi478kwy3j30r60anq9m.jpg)

1. 模板是作用在编译时，==在编译时实例化出所需要的的函数或类==！看上去跟宏差不多！

   但是作用在宏之后(宏作用在预处理阶段)。

2. 在单一源文件中必须得用模板的==定义==！否则无法在编译时实例化出定义！

3. 所以模板的定义一般实现在==头文件==中！

4. 但是模板不会重复定义！

   因为在链接阶段会合并==相同的模板实例化出的相同函数/类==！

5. 如何看.o文件中的所有定义？

```c++
nm -C xxx.o
```





# 3.模板函数

## 3.1add模板

1. 显式模板实例化

```c++
//以上面实现的add模板为例
add<double>(2.5, 3)
//如果没有显式，那就是隐式推导
```

2. `decltype()`

   ==自动推导表达式返回值类型==

   其实也可以算是typeof()的升级版！

3. 如何让add模板也可以支持不同类型的加法？

   参数列表加一个！

   那返回值类型咋办？

   用`decltype()`

   ```c++
   template<typename T, typename U>
   decltype(T() + U()) add(T a, U b) {//为啥是T() + U()呢？因为两个类型不能直接相加，但是两个对象可以相加，T()是调用其默认构造函数生成T对象！
       return a + b;
   }
   ```

4. 但是上述版本还是有bug！

   ***<u>因为如果这两个对象没有默认构造函数就不行了！</u>***

   ```c++
   template<typename T, typename U>
   auto add(T a, U b) -> decltype(a + b) {
       //返回值后置，到了decltype这就可以看到a，b变量了，就可以直接推导出返回值了！
       return a + b;
   }
   ```

   





## 3.2max模板

1. C++中stl中的max模板是有缺陷的，不能支持***<u>不同类型</u>***的比较！

2. 其实如果实现了max模板，就可以实现比较两个值min，等于，不等于了！

   ==这样只需要这两种类型支持`operator>`就行了！==

3. 实现：

   ```c++
   template<typename T, typename U>
   auto max(T a, U b) -> decltype(a + b) { //为什么不用decltype(a > b ? a : b)呢？
       return a > b ? a : b;               //因为?:不能重载，不能自动类型推导！
   }
   
   template<typename T, typename U>
   auto max(T a, U b) -> decltype(a + b) {
       return a > b ? b : a;
   }
   ```

   疑问：

   ==既然?:不能重载，那么模板函数体中为什么能用?:呢？？？？？==



# 4.模板类

```c++
namespace haizei {
template<typename T>
class PrintAny {
    void operator()(const T &a) {   //输出任意类型！！
        cout << a << endl;  
    }
};
    
    
}

int main() {
    //这个模板类缺点很明显，要想打印某个类型，必须实例化出相关对象！
    haizei::PrintAny<int> print1;//只能打印整型变量
    haizei::PrintAny<string> print2;//只能打印string
    
    
    return 0;
}
```



# 5.类中模板函数

```c++
namespace haizei {
class PrintAny {
    template<typename T>
    void operator()(const T &a) {   //输出任意类型！！
        cout << a << endl;  
    }
};
    
    
}

int main() {
    haizei::PrintAny print;//实例化出对象；
    //可以打印任意类型！
    print(123);//实例化出operator()(int)
    print(5.4);//实例化出operator()(double)
    print("hello world!");//实例化出operator()(string)
    
    return 0;
}
```







# 6.模板特化与偏特化

## 6.1特化

1. 定义：

   ==对某种特殊类型的特殊处理==

2. 例子：

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghi4j3n0h1j31mk0patsa.jpg)

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghi4k4mqcjj315i0oy7mr.jpg)

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghi4k7slacj314q0oqng7.jpg)

   

   

   ## 6.2偏特化

   1. 定义

      ==针对template参数更进一步的条件限制所设计出来的一个特化版本。比如指针类型==

   2. 例子

      ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ghi4n25s5qj31mg0qgkbu.jpg)

      ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ghi4sn34csj30f0030ab3.jpg)

      







# 7.变参模板

## 7.1基本语法

1. 基本语法：

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghi5jh7uc0j31uu0mwh89.jpg)

+ `...代表是可变参数,ARGS相当于给可变参数类型列表起的名字`

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ghi5jl0y2rj31nq0r0qv3.jpg)

+ `args`相当于给函数的可变参数列表起名字







## 7.2解析工具

1. `ARG<ARGS...>`是一个工具类，作用就是==解析`ARGS...`中的参数类型==

```c++
namespace haizei {
    
template<typename T, typename ...ARGS> class Test;//声明
    
template<typename T, typename ...ARGS> //偏特化版本
class Test<T(ARGS...)> {//这个偏特化版本必须这样实例化这个类
public:
    T operator()(
        		typename ARG<ARGS...>::__type a,
                 typename ARG<ARGS...>::__rest::__type b) {  //ARG是一个模板类(其功能可以说是工具类)，实例化参数是变参列表
        //__type，__rest是ARG类中的成员属性
        //如果想拿出变参列表中的第三个，可以这么写
        //typename ARG<ARGS...>::__rest::__rest::__type c
        //这个operator()传入参数是变参列表中的第一个和第二个对象
        return a + b;
    }
}；
    
    
}
    
int main() {
    haizei::Test<int(int, int)> f;//f是一个函数对象
    //也就是说，如果用operator()，那么
    //返回int型(实例化的第一个参数)的两个int类型(实例化的第2、3个参数)的对象的和
    cout << f(3, 4) << endl;
    
    return 0;
}
```

